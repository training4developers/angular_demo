{"version":3,"file":"animations-browser.umd.js","sources":["../../../../packages/animations/browser/src/render/web_animations/web_animations_driver.ts","../../../../packages/animations/browser/src/render/web_animations/web_animations_player.ts","../../../../packages/animations/browser/src/render/noop_animation_engine.ts","../../../../packages/animations/browser/src/dsl/style_normalization/web_animations_style_normalizer.ts","../../../../packages/animations/browser/src/dsl/animation.ts","../../../../packages/animations/browser/src/dsl/style_normalization/animation_style_normalizer.ts","../../../../packages/animations/browser/src/render/dom_animation_engine.ts","../../../../packages/animations/browser/src/dsl/animation_trigger.ts","../../../../packages/animations/browser/src/dsl/animation_validator_visitor.ts","../../../../packages/animations/browser/src/dsl/animation_transition_factory.ts","../../../../packages/animations/browser/src/dsl/animation_transition_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_visitor.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts","../../../../packages/animations/browser/src/dsl/animation_dsl_visitor.ts","../../../../packages/animations/browser/src/util.ts","../../../../packages/animations/browser/src/animation_engine.ts","../../../../packages/animations/browser/src/render/animation_driver.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../animation_driver';\n\nimport {WebAnimationsPlayer} from './web_animations_player';\nexport class WebAnimationsDriver implements AnimationDriver {\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?=} previousPlayers\n * @return {?}\n */\nanimate(\n      element: any, keyframes: ɵStyleData[], duration: number, delay: number, easing: string,\n      previousPlayers: AnimationPlayer[] = []): WebAnimationsPlayer {\n    const /** @type {?} */ playerOptions: {[key: string]: string |\n                              number} = {'duration': duration, 'delay': delay, 'fill': 'forwards'};\n\n    // we check for this to avoid having a null|undefined value be present\n    // for the easing (which results in an error for certain browsers #9752)\n    if (easing) {\n      playerOptions['easing'] = easing;\n    }\n\n    const /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */(( <WebAnimationsPlayer[]>previousPlayers.filter(\n        player => { return player instanceof WebAnimationsPlayer; })));\n    return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);\n  }\n}\n/**\n * @return {?}\n */\nexport function supportsWebAnimations() {\n  return typeof Element !== 'undefined' && typeof( /** @type {?} */((<any>Element))).prototype['animate'] === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationPlayer} from '@angular/animations';\nimport {DOMAnimation} from './dom_animation';\nexport class WebAnimationsPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _onDestroyFns: Function[] = [];\nprivate _player: DOMAnimation;\nprivate _duration: number;\nprivate _delay: number;\nprivate _initialized = false;\nprivate _finished = false;\nprivate _started = false;\nprivate _destroyed = false;\nprivate _finalKeyframe: {[key: string]: string | number};\npublic time = 0;\npublic parentPlayer: AnimationPlayer = null;\npublic previousStyles: {[styleName: string]: string | number};\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @param {?=} previousPlayers\n */\nconstructor(\npublic element: any,\npublic keyframes: {[key: string]: string | number}[],\npublic options: {[key: string]: string | number},\n      previousPlayers: WebAnimationsPlayer[] = []) {\n    this._duration = <number>options['duration'];\n    this._delay = <number>options['delay'] || 0;\n    this.time = this._duration + this._delay;\n\n    this.previousStyles = {};\n    previousPlayers.forEach(player => {\n      let styles = player._captureStyles();\n      Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n    });\n  }\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @return {?}\n */\ninit(): void {\n    if (this._initialized) return;\n    this._initialized = true;\n\n    const /** @type {?} */ keyframes = this.keyframes.map(styles => {\n      const /** @type {?} */ formattedKeyframe: {[key: string]: string | number} = {};\n      Object.keys(styles).forEach((prop, index) => {\n        let /** @type {?} */ value = styles[prop];\n        if (value == AUTO_STYLE) {\n          value = _computeStyle(this.element, prop);\n        }\n        if (value != undefined) {\n          formattedKeyframe[prop] = value;\n        }\n      });\n      return formattedKeyframe;\n    });\n\n    const /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);\n    if (previousStyleProps.length) {\n      let /** @type {?} */ startingKeyframe = keyframes[0];\n      let /** @type {?} */ missingStyleProps: string[] = [];\n      previousStyleProps.forEach(prop => {\n        if (startingKeyframe[prop] != null) {\n          missingStyleProps.push(prop);\n        }\n        startingKeyframe[prop] = this.previousStyles[prop];\n      });\n\n      if (missingStyleProps.length) {\n        const /** @type {?} */ self = this;\n        // tslint:disable-next-line\n        for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {\n          let /** @type {?} */ kf = keyframes[i];\n          missingStyleProps.forEach(function(prop) {\n            kf[prop] = _computeStyle(self.element, prop);\n          });\n        }\n      }\n    }\n\n    this._player = this._triggerWebAnimation(this.element, keyframes, this.options);\n    this._finalKeyframe =\n        keyframes.length ? _copyKeyframeStyles(keyframes[keyframes.length - 1]) : {};\n\n    // this is required so that the player doesn't start to animate right away\n    this._resetDomPlayerState();\n    this._player.addEventListener('finish', () => this._onFinish());\n  }\n/**\n * \\@internal\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @return {?}\n */\n_triggerWebAnimation(element: any, keyframes: any[], options: any): DOMAnimation {\n    // jscompiler doesn't seem to know animate is a native property because it's not fully\n    // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\n    return /** @type {?} */(( <DOMAnimation>element['animate'](keyframes, options)));\n  }\n/**\n * @return {?}\n */\nget domPlayer() { return this._player; }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nplay(): void {\n    this.init();\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n    }\n    this._player.play();\n  }\n/**\n * @return {?}\n */\npause(): void {\n    this.init();\n    this._player.pause();\n  }\n/**\n * @return {?}\n */\nfinish(): void {\n    this.init();\n    this._onFinish();\n    this._player.finish();\n  }\n/**\n * @return {?}\n */\nreset(): void {\n    this._resetDomPlayerState();\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n/**\n * @return {?}\n */\nprivate _resetDomPlayerState() {\n    if (this._player) {\n      this._player.cancel();\n    }\n  }\n/**\n * @return {?}\n */\nrestart(): void {\n    this.reset();\n    this.play();\n  }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this._started; }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (!this._destroyed) {\n      this._resetDomPlayerState();\n      this._onFinish();\n      this._destroyed = true;\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void { this._player.currentTime = p * this.time; }\n/**\n * @return {?}\n */\ngetPosition(): number { return this._player.currentTime / this.time; }\n/**\n * @return {?}\n */\nprivate _captureStyles(): {[prop: string]: string | number} {\n    const /** @type {?} */ styles: {[key: string]: string | number} = {};\n    if (this.hasStarted()) {\n      Object.keys(this._finalKeyframe).forEach(prop => {\n        if (prop != 'offset') {\n          styles[prop] =\n              this._finished ? this._finalKeyframe[prop] : _computeStyle(this.element, prop);\n        }\n      });\n    }\n\n    return styles;\n  }\n}\n\nfunction WebAnimationsPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDoneFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onStartFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDestroyFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._player;\n/** @type {?} */\nWebAnimationsPlayer.prototype._duration;\n/** @type {?} */\nWebAnimationsPlayer.prototype._delay;\n/** @type {?} */\nWebAnimationsPlayer.prototype._initialized;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finished;\n/** @type {?} */\nWebAnimationsPlayer.prototype._started;\n/** @type {?} */\nWebAnimationsPlayer.prototype._destroyed;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finalKeyframe;\n/** @type {?} */\nWebAnimationsPlayer.prototype.time;\n/** @type {?} */\nWebAnimationsPlayer.prototype.parentPlayer;\n/** @type {?} */\nWebAnimationsPlayer.prototype.previousStyles;\n/** @type {?} */\nWebAnimationsPlayer.prototype.element;\n/** @type {?} */\nWebAnimationsPlayer.prototype.keyframes;\n/** @type {?} */\nWebAnimationsPlayer.prototype.options;\n}\n\n/**\n * @param {?} element\n * @param {?} prop\n * @return {?}\n */\nfunction _computeStyle(element: any, prop: string): string {\n  return ( /** @type {?} */((<any>window.getComputedStyle(element))))[prop];\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nfunction _copyKeyframeStyles(styles: {[style: string]: string | number}):\n    {[style: string]: string | number} {\n  const /** @type {?} */ newStyles: {[style: string]: string | number} = {};\n  Object.keys(styles).forEach(prop => {\n    if (prop != 'offset') {\n      newStyles[prop] = styles[prop];\n    }\n  });\n  return newStyles;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationEvent, AnimationMetadataType, AnimationPlayer, AnimationStateMetadata, AnimationTriggerMetadata, ɵStyleData} from '@angular/animations';\n\nimport {AnimationEngine} from '../animation_engine';\nimport {copyStyles, eraseStyles, normalizeStyles, setStyles} from '../util';\n\ninterface ListenerTuple {\n  eventPhase: string;\n  triggerName: string;\n  callback: (event: any) => any;\n  doRemove?: boolean;\n}\n\ninterface ChangeTuple {\n  element: any;\n  triggerName: string;\n  oldValue: string;\n  newValue: string;\n}\n\nconst /** @type {?} */ DEFAULT_STATE_VALUE = 'void';\nconst /** @type {?} */ DEFAULT_STATE_STYLES = '*';\nexport class NoopAnimationEngine extends AnimationEngine {\nprivate _listeners = new Map<any, ListenerTuple[]>();\nprivate _changes: ChangeTuple[] = [];\nprivate _flaggedRemovals = new Set<any>();\nprivate _onDoneFns: (() => any)[] = [];\nprivate _triggerStyles: {[triggerName: string]: {[stateName: string]: ɵStyleData}} =\n      Object.create(null);\n/**\n * @param {?} trigger\n * @param {?=} name\n * @return {?}\n */\nregisterTrigger(trigger: AnimationTriggerMetadata, name: string = null): void {\n    name = name || trigger.name;\n    if (this._triggerStyles[name]) {\n      return;\n    }\n    const /** @type {?} */ stateMap: {[stateName: string]: ɵStyleData} = {};\n    trigger.definitions.forEach(def => {\n      if (def.type === AnimationMetadataType.State) {\n        const /** @type {?} */ stateDef = /** @type {?} */(( def as AnimationStateMetadata));\n        stateMap[stateDef.name] = normalizeStyles(stateDef.styles.styles);\n      }\n    });\n    this._triggerStyles[name] = stateMap;\n  }\n/**\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonInsert(element: any, domFn: () => any): void { domFn(); }\n/**\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonRemove(element: any, domFn: () => any): void {\n    domFn();\n    this._flaggedRemovals.add(element);\n  }\n/**\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(element: any, property: string, value: any): void {\n    const /** @type {?} */ storageProp = makeStorageProp(property);\n    const /** @type {?} */ oldValue = element[storageProp] || DEFAULT_STATE_VALUE;\n    this._changes.push( /** @type {?} */((<ChangeTuple>{element, oldValue, newValue: value, triggerName: property})));\n\n    const /** @type {?} */ triggerStateStyles = this._triggerStyles[property] || {};\n    const /** @type {?} */ fromStateStyles =\n        triggerStateStyles[oldValue] || triggerStateStyles[DEFAULT_STATE_STYLES];\n    if (fromStateStyles) {\n      eraseStyles(element, fromStateStyles);\n    }\n\n    element[storageProp] = value;\n    this._onDoneFns.push(() => {\n      const /** @type {?} */ toStateStyles = triggerStateStyles[value] || triggerStateStyles[DEFAULT_STATE_STYLES];\n      if (toStateStyles) {\n        setStyles(element, toStateStyles);\n      }\n    });\n  }\n/**\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(element: any, eventName: string, eventPhase: string, callback: (event: any) => any):\n      () => any {\n    let /** @type {?} */ listeners = this._listeners.get(element);\n    if (!listeners) {\n      this._listeners.set(element, listeners = []);\n    }\n\n    const /** @type {?} */ tuple = /** @type {?} */(( <ListenerTuple>{triggerName: eventName, eventPhase, callback}));\n    listeners.push(tuple);\n\n    return () => tuple.doRemove = true;\n  }\n/**\n * @return {?}\n */\nflush(): void {\n    const /** @type {?} */ onStartCallbacks: (() => any)[] = [];\n    const /** @type {?} */ onDoneCallbacks: (() => any)[] = [];\n/**\n * @param {?} listener\n * @param {?} data\n * @return {?}\n */\nfunction handleListener(listener: ListenerTuple, data: ChangeTuple) {\n      const /** @type {?} */ phase = listener.eventPhase;\n      const /** @type {?} */ event = makeAnimationEvent(\n          data.element, data.triggerName, data.oldValue, data.newValue, phase, 0);\n      if (phase == 'start') {\n        onStartCallbacks.push(() => listener.callback(event));\n      } else if (phase == 'done') {\n        onDoneCallbacks.push(() => listener.callback(event));\n      }\n    }\n\n    this._changes.forEach(change => {\n      const /** @type {?} */ element = change.element;\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          if (listener.triggerName == change.triggerName) {\n            handleListener(listener, change);\n          }\n        });\n      }\n    });\n\n    // upon removal ALL the animation triggers need to get fired\n    this._flaggedRemovals.forEach(element => {\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          const /** @type {?} */ triggerName = listener.triggerName;\n          const /** @type {?} */ storageProp = makeStorageProp(triggerName);\n          handleListener(listener, /** @type {?} */(( <ChangeTuple>{\n            element: element,\n            triggerName: triggerName,\n            oldValue: element[storageProp] || DEFAULT_STATE_VALUE,\n            newValue: DEFAULT_STATE_VALUE\n          })));\n        });\n      }\n    });\n\n    // remove all the listeners after everything is complete\n    Array.from(this._listeners.keys()).forEach(element => {\n      const /** @type {?} */ listenersToKeep = this._listeners.get(element).filter(l => !l.doRemove);\n      if (listenersToKeep.length) {\n        this._listeners.set(element, listenersToKeep);\n      } else {\n        this._listeners.delete(element);\n      }\n    });\n\n    onStartCallbacks.forEach(fn => fn());\n    onDoneCallbacks.forEach(fn => fn());\n    this._flaggedRemovals.clear();\n    this._changes = [];\n\n    this._onDoneFns.forEach(doneFn => doneFn());\n    this._onDoneFns = [];\n  }\n/**\n * @return {?}\n */\nget activePlayers(): AnimationPlayer[] { return []; }\n/**\n * @return {?}\n */\nget queuedPlayers(): AnimationPlayer[] { return []; }\n}\n\nfunction NoopAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopAnimationEngine.prototype._listeners;\n/** @type {?} */\nNoopAnimationEngine.prototype._changes;\n/** @type {?} */\nNoopAnimationEngine.prototype._flaggedRemovals;\n/** @type {?} */\nNoopAnimationEngine.prototype._onDoneFns;\n/** @type {?} */\nNoopAnimationEngine.prototype._triggerStyles;\n}\n\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} phaseName\n * @param {?} totalTime\n * @return {?}\n */\nfunction makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string,\n    totalTime: number): AnimationEvent {\n  return /** @type {?} */(( <AnimationEvent>{element, triggerName, fromState, toState, phaseName, totalTime}));\n}\n/**\n * @param {?} property\n * @return {?}\n */\nfunction makeStorageProp(property: string): string {\n  return '_@_' + property;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationStyleNormalizer} from './animation_style_normalizer';\nexport class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string {\n    return dashCaseToCamelCase(propertyName);\n  }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    let /** @type {?} */ unit: string = '';\n    const /** @type {?} */ strVal = value.toString().trim();\n\n    if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {\n      if (typeof value === 'number') {\n        unit = 'px';\n      } else {\n        const /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);\n        }\n      }\n    }\n    return strVal + unit;\n  }\n}\n\nconst /** @type {?} */ DIMENSIONAL_PROP_MAP = makeBooleanMap(\n    'width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent'\n        .split(','));\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction makeBooleanMap(keys: string[]): {[key: string]: boolean} {\n  const /** @type {?} */ map: {[key: string]: boolean} = {};\n  keys.forEach(key => map[key] = true);\n  return map;\n}\n\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationPlayer, AnimationStyleMetadata, sequence, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../render/animation_driver';\nimport {DomAnimationEngine} from '../render/dom_animation_engine';\nimport {normalizeStyles} from '../util';\n\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\nimport {buildAnimationKeyframes} from './animation_timeline_visitor';\nimport {validateAnimationSequence} from './animation_validator_visitor';\nimport {AnimationStyleNormalizer} from './style_normalization/animation_style_normalizer';\nexport class Animation {\nprivate _animationAst: AnimationMetadata;\n/**\n * @param {?} input\n */\nconstructor(input: AnimationMetadata|AnimationMetadata[]) {\n    const ast =\n        Array.isArray(input) ? sequence(<AnimationMetadata[]>input) : <AnimationMetadata>input;\n    const errors = validateAnimationSequence(ast);\n    if (errors.length) {\n      const errorMessage = `animation validation failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n    this._animationAst = ast;\n  }\n/**\n * @param {?} startingStyles\n * @param {?} destinationStyles\n * @return {?}\n */\nbuildTimelines(\n      startingStyles: ɵStyleData|ɵStyleData[],\n      destinationStyles: ɵStyleData|ɵStyleData[]): AnimationTimelineInstruction[] {\n    const /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */((\n                                                  <ɵStyleData>startingStyles));\n    const /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */((\n                                                    <ɵStyleData>destinationStyles));\n    return buildAnimationKeyframes(this._animationAst, start, dest);\n  }\n/**\n * @param {?} injector\n * @param {?} element\n * @param {?=} startingStyles\n * @param {?=} destinationStyles\n * @return {?}\n */\nprivate create(\n      injector: any, element: any, startingStyles: ɵStyleData = {},\n      destinationStyles: ɵStyleData = {}): AnimationPlayer {\n    const /** @type {?} */ instructions = this.buildTimelines(startingStyles, destinationStyles);\n\n    // note the code below is only here to make the tests happy (once the new renderer is\n    // within core then the code below will interact with Renderer.transition(...))\n    const /** @type {?} */ driver: AnimationDriver = injector.get(AnimationDriver);\n    const /** @type {?} */ normalizer: AnimationStyleNormalizer = injector.get(AnimationStyleNormalizer);\n    const /** @type {?} */ engine = new DomAnimationEngine(driver, normalizer);\n    return engine.animateTimeline(element, instructions);\n  }\n}\n\nfunction Animation_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimation.prototype._animationAst;\n}\n\n","\n/**\n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationStyleNormalizer {\n/**\n * @abstract\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]) {}\n/**\n * @abstract\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]) {}\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class NoopAnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string { return propertyName; }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    return /** @type {?} */(( <any>value));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationEvent, AnimationPlayer, AnimationTriggerMetadata, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger, buildTrigger} from '../dsl/animation_trigger';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {eraseStyles, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\n\nexport interface QueuedAnimationTransitionTuple {\n  element: any;\n  player: AnimationPlayer;\n  triggerName: string;\n  event: AnimationEvent;\n}\n\nexport interface TriggerListenerTuple {\n  triggerName: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nconst /** @type {?} */ MARKED_FOR_ANIMATION = 'ng-animate';\nconst /** @type {?} */ MARKED_FOR_REMOVAL = '$$ngRemove';\nexport class DomAnimationEngine {\nprivate _flaggedInserts = new Set<any>();\nprivate _queuedRemovals = new Map<any, () => any>();\nprivate _queuedTransitionAnimations: QueuedAnimationTransitionTuple[] = [];\nprivate _activeTransitionAnimations = new Map<any, {[triggerName: string]: AnimationPlayer}>();\nprivate _activeElementAnimations = new Map<any, AnimationPlayer[]>();\nprivate _elementTriggerStates = new Map<any, {[triggerName: string]: string}>();\nprivate _triggers: {[triggerName: string]: AnimationTrigger} = Object.create(null);\nprivate _triggerListeners = new Map<any, TriggerListenerTuple[]>();\nprivate _pendingListenerRemovals = new Map<any, TriggerListenerTuple[]>();\n/**\n * @param {?} _driver\n * @param {?} _normalizer\n */\nconstructor(private _driver: AnimationDriver,\nprivate _normalizer: AnimationStyleNormalizer) {}\n/**\n * @return {?}\n */\nget queuedPlayers(): AnimationPlayer[] {\n    return this._queuedTransitionAnimations.map(q => q.player);\n  }\n/**\n * @return {?}\n */\nget activePlayers(): AnimationPlayer[] {\n    const /** @type {?} */ players: AnimationPlayer[] = [];\n    this._activeElementAnimations.forEach(activePlayers => players.push(...activePlayers));\n    return players;\n  }\n/**\n * @param {?} trigger\n * @param {?=} name\n * @return {?}\n */\nregisterTrigger(trigger: AnimationTriggerMetadata, name: string = null): void {\n    name = name || trigger.name;\n    if (this._triggers[name]) {\n      return;\n    }\n    this._triggers[name] = buildTrigger(name, trigger.definitions);\n  }\n/**\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonInsert(element: any, domFn: () => any): void {\n    this._flaggedInserts.add(element);\n    domFn();\n  }\n/**\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonRemove(element: any, domFn: () => any): void {\n    let /** @type {?} */ lookupRef = this._elementTriggerStates.get(element);\n    if (lookupRef) {\n      const /** @type {?} */ possibleTriggers = Object.keys(lookupRef);\n      const /** @type {?} */ hasRemoval = possibleTriggers.some(triggerName => {\n        const /** @type {?} */ oldValue = lookupRef[triggerName];\n        const /** @type {?} */ instruction = this._triggers[triggerName].matchTransition(oldValue, 'void');\n        return !!instruction;\n      });\n      if (hasRemoval) {\n        element[MARKED_FOR_REMOVAL] = true;\n        this._queuedRemovals.set(element, domFn);\n        return;\n      }\n    }\n\n    // this means that there are no animations to take on this\n    // leave operation therefore we should fire the done|start callbacks\n    if (this._triggerListeners.has(element)) {\n      element[MARKED_FOR_REMOVAL] = true;\n      this._queuedRemovals.set(element, () => {});\n    }\n    domFn();\n  }\n/**\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(element: any, property: string, value: any): void {\n    const /** @type {?} */ trigger = this._triggers[property];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${property}\" has not been registered!`);\n    }\n\n    let /** @type {?} */ lookupRef = this._elementTriggerStates.get(element);\n    if (!lookupRef) {\n      this._elementTriggerStates.set(element, lookupRef = {});\n    }\n\n    let /** @type {?} */ oldValue = lookupRef[property] || 'void';\n    if (oldValue != value) {\n      let /** @type {?} */ instruction = trigger.matchTransition(oldValue, value);\n      if (!instruction) {\n        // we do this to make sure we always have an animation player so\n        // that callback operations are properly called\n        instruction = trigger.createFallbackInstruction(oldValue, value);\n      }\n      this.animateTransition(element, instruction);\n      lookupRef[property] = value;\n    }\n  }\n/**\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(element: any, eventName: string, eventPhase: string, callback: (event: any) => any):\n      () => void {\n    if (!eventPhase) {\n      throw new Error(\n          `Unable to listen on the animation trigger \"${eventName}\" because the provided event is undefined!`);\n    }\n    if (!this._triggers[eventName]) {\n      throw new Error(\n          `Unable to listen on the animation trigger event \"${eventPhase}\" because the animation trigger \"${eventName}\" doesn't exist!`);\n    }\n    let /** @type {?} */ elementListeners = this._triggerListeners.get(element);\n    if (!elementListeners) {\n      this._triggerListeners.set(element, elementListeners = []);\n    }\n    validatePlayerEvent(eventName, eventPhase);\n    const /** @type {?} */ tuple = /** @type {?} */(( <TriggerListenerTuple>{triggerName: eventName, phase: eventPhase, callback}));\n    elementListeners.push(tuple);\n    return () => {\n      // this is queued up in the event that a removal animation is set\n      // to fire on the element (the listeners need to be set during flush)\n      getOrSetAsInMap(this._pendingListenerRemovals, element, []).push(tuple);\n    };\n  }\n/**\n * @return {?}\n */\nprivate _clearPendingListenerRemovals() {\n    this._pendingListenerRemovals.forEach((tuples: TriggerListenerTuple[], element: any) => {\n      const /** @type {?} */ elementListeners = this._triggerListeners.get(element);\n      if (elementListeners) {\n        tuples.forEach(tuple => {\n          const /** @type {?} */ index = elementListeners.indexOf(tuple);\n          if (index >= 0) {\n            elementListeners.splice(index, 1);\n          }\n        });\n      }\n    });\n    this._pendingListenerRemovals.clear();\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nprivate _onRemovalTransition(element: any): AnimationPlayer[] {\n    // when a parent animation is set to trigger a removal we want to\n    // find all of the children that are currently animating and clear\n    // them out by destroying each of them.\n    const /** @type {?} */ elms = element.querySelectorAll(MARKED_FOR_ANIMATION);\n    for (let /** @type {?} */ i = 0; i < elms.length; i++) {\n      const /** @type {?} */ elm = elms[i];\n      const /** @type {?} */ activePlayers = this._activeElementAnimations.get(elm);\n      if (activePlayers) {\n        activePlayers.forEach(player => player.destroy());\n      }\n\n      const /** @type {?} */ activeTransitions = this._activeTransitionAnimations.get(elm);\n      if (activeTransitions) {\n        Object.keys(activeTransitions).forEach(triggerName => {\n          const /** @type {?} */ player = activeTransitions[triggerName];\n          if (player) {\n            player.destroy();\n          }\n        });\n      }\n    }\n\n    // we make a copy of the array because the actual source array is modified\n    // each time a player is finished/destroyed (the forEach loop would fail otherwise)\n    return copyArray(this._activeElementAnimations.get(element));\n  }\n/**\n * @param {?} element\n * @param {?} instruction\n * @return {?}\n */\nanimateTransition(element: any, instruction: AnimationTransitionInstruction): AnimationPlayer {\n    const /** @type {?} */ triggerName = instruction.triggerName;\n\n    let /** @type {?} */ previousPlayers: AnimationPlayer[];\n    if (instruction.isRemovalTransition) {\n      previousPlayers = this._onRemovalTransition(element);\n    } else {\n      previousPlayers = [];\n      const /** @type {?} */ existingTransitions = this._activeTransitionAnimations.get(element);\n      const /** @type {?} */ existingPlayer = existingTransitions ? existingTransitions[triggerName] : null;\n      if (existingPlayer) {\n        previousPlayers.push(existingPlayer);\n      }\n    }\n\n    // it's important to do this step before destroying the players\n    // so that the onDone callback below won't fire before this\n    eraseStyles(element, instruction.fromStyles);\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    let /** @type {?} */ totalTime = 0;\n    const /** @type {?} */ players = instruction.timelines.map(timelineInstruction => {\n      totalTime = Math.max(totalTime, timelineInstruction.totalTime);\n      return this._buildPlayer(element, timelineInstruction, previousPlayers);\n    });\n\n    previousPlayers.forEach(previousPlayer => previousPlayer.destroy());\n    const /** @type {?} */ player = optimizeGroupPlayer(players);\n    player.onDone(() => {\n      player.destroy();\n      const /** @type {?} */ elmTransitionMap = this._activeTransitionAnimations.get(element);\n      if (elmTransitionMap) {\n        delete elmTransitionMap[triggerName];\n        if (Object.keys(elmTransitionMap).length == 0) {\n          this._activeTransitionAnimations.delete(element);\n        }\n      }\n      deleteFromArrayMap(this._activeElementAnimations, element, player);\n      setStyles(element, instruction.toStyles);\n    });\n\n    const /** @type {?} */ elmTransitionMap = getOrSetAsInMap(this._activeTransitionAnimations, element, {});\n    elmTransitionMap[triggerName] = player;\n\n    this._queuePlayer(\n        element, triggerName, player,\n        makeAnimationEvent(\n            element, triggerName, instruction.fromState, instruction.toState,\n            null,  // this will be filled in during event creation\n            totalTime));\n\n    return player;\n  }\n/**\n * @param {?} element\n * @param {?} instructions\n * @param {?=} previousPlayers\n * @return {?}\n */\npublic animateTimeline(\n      element: any, instructions: AnimationTimelineInstruction[],\n      previousPlayers: AnimationPlayer[] = []): AnimationPlayer {\n    const /** @type {?} */ players = instructions.map(instruction => {\n      const /** @type {?} */ player = this._buildPlayer(element, instruction, previousPlayers);\n      player.onDestroy(\n          () => { deleteFromArrayMap(this._activeElementAnimations, element, player); });\n      player.init();\n\n      this._markPlayerAsActive(element, player);\n      return player;\n    });\n    return optimizeGroupPlayer(players);\n  }\n/**\n * @param {?} element\n * @param {?} instruction\n * @param {?} previousPlayers\n * @return {?}\n */\nprivate _buildPlayer(\n      element: any, instruction: AnimationTimelineInstruction,\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    return this._driver.animate(\n        element, this._normalizeKeyframes(instruction.keyframes), instruction.duration,\n        instruction.delay, instruction.easing, previousPlayers);\n  }\n/**\n * @param {?} keyframes\n * @return {?}\n */\nprivate _normalizeKeyframes(keyframes: ɵStyleData[]): ɵStyleData[] {\n    const /** @type {?} */ errors: string[] = [];\n    const /** @type {?} */ normalizedKeyframes: ɵStyleData[] = [];\n    keyframes.forEach(kf => {\n      const /** @type {?} */ normalizedKeyframe: ɵStyleData = {};\n      Object.keys(kf).forEach(prop => {\n        let /** @type {?} */ normalizedProp = prop;\n        let /** @type {?} */ normalizedValue = kf[prop];\n        if (prop != 'offset') {\n          normalizedProp = this._normalizer.normalizePropertyName(prop, errors);\n          normalizedValue =\n              this._normalizer.normalizeStyleValue(prop, normalizedProp, kf[prop], errors);\n        }\n        normalizedKeyframe[normalizedProp] = normalizedValue;\n      });\n      normalizedKeyframes.push(normalizedKeyframe);\n    });\n    if (errors.length) {\n      const /** @type {?} */ LINE_START = '\\n - ';\n      throw new Error(\n          `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n    }\n    return normalizedKeyframes;\n  }\n/**\n * @param {?} element\n * @param {?} player\n * @return {?}\n */\nprivate _markPlayerAsActive(element: any, player: AnimationPlayer) {\n    const /** @type {?} */ elementAnimations = getOrSetAsInMap(this._activeElementAnimations, element, []);\n    elementAnimations.push(player);\n  }\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} player\n * @param {?} event\n * @return {?}\n */\nprivate _queuePlayer(\n      element: any, triggerName: string, player: AnimationPlayer, event: AnimationEvent) {\n    const /** @type {?} */ tuple = /** @type {?} */(( <QueuedAnimationTransitionTuple>{element, player, triggerName, event}));\n    this._queuedTransitionAnimations.push(tuple);\n    player.init();\n\n    element.classList.add(MARKED_FOR_ANIMATION);\n    player.onDone(() => { element.classList.remove(MARKED_FOR_ANIMATION); });\n  }\n/**\n * @return {?}\n */\nprivate _flushQueuedAnimations() {\n    parentLoop: while (this._queuedTransitionAnimations.length) {\n      const {player, element, triggerName, event} = this._queuedTransitionAnimations.shift();\n\n      let /** @type {?} */ parent = element;\n      while (parent = parent.parentNode) {\n        // this means that a parent element will or will not\n        // have its own animation operation which in this case\n        // there's no point in even trying to do an animation\n        if (parent[MARKED_FOR_REMOVAL]) continue parentLoop;\n      }\n\n      const /** @type {?} */ listeners = this._triggerListeners.get(element);\n      if (listeners) {\n        listeners.forEach(tuple => {\n          if (tuple.triggerName == triggerName) {\n            listenOnPlayer(player, tuple.phase, event, tuple.callback);\n          }\n        });\n      }\n\n      // if a removal exists for the given element then we need cancel\n      // all the queued players so that a proper removal animation can go\n      if (this._queuedRemovals.has(element)) {\n        player.destroy();\n        continue;\n      }\n\n      this._markPlayerAsActive(element, player);\n\n      // in the event that an animation throws an error then we do\n      // not want to re-run animations on any previous animations\n      // if they have already been kicked off beforehand\n      if (!player.hasStarted()) {\n        player.play();\n      }\n    }\n  }\n/**\n * @return {?}\n */\nflush() {\n    const /** @type {?} */ leaveListeners = new Map<any, TriggerListenerTuple[]>();\n    this._queuedRemovals.forEach((callback, element) => {\n      const /** @type {?} */ tuple = this._pendingListenerRemovals.get(element);\n      if (tuple) {\n        leaveListeners.set(element, tuple);\n        this._pendingListenerRemovals.delete(element);\n      }\n    });\n\n    this._clearPendingListenerRemovals();\n    this._pendingListenerRemovals = leaveListeners;\n\n    this._flushQueuedAnimations();\n\n    let /** @type {?} */ flushAgain = false;\n    this._queuedRemovals.forEach((callback, element) => {\n      // an item that was inserted/removed in the same flush means\n      // that an animation should not happen anyway\n      if (this._flaggedInserts.has(element)) return;\n\n      let /** @type {?} */ parent = element;\n      let /** @type {?} */ players: AnimationPlayer[] = [];\n      while (parent = parent.parentNode) {\n        // there is no reason to even try to\n        if (parent[MARKED_FOR_REMOVAL]) {\n          callback();\n          return;\n        }\n\n        const /** @type {?} */ match = this._activeElementAnimations.get(parent);\n        if (match) {\n          players.push(...match);\n          break;\n        }\n      }\n\n      // the loop was unable to find an parent that is animating even\n      // though this element has set to be removed, so the algorithm\n      // should check to see if there are any triggers on the element\n      // that are present to handle a leave animation and then setup\n      // those players to facilitate the callback after done\n      if (players.length == 0) {\n        // this means that the element has valid state triggers\n        const /** @type {?} */ stateDetails = this._elementTriggerStates.get(element);\n        if (stateDetails) {\n          Object.keys(stateDetails).forEach(triggerName => {\n            flushAgain = true;\n            const /** @type {?} */ oldValue = stateDetails[triggerName];\n            const /** @type {?} */ instruction = this._triggers[triggerName].matchTransition(oldValue, 'void');\n            if (instruction) {\n              players.push(this.animateTransition(element, instruction));\n            } else {\n              const /** @type {?} */ event = makeAnimationEvent(element, triggerName, oldValue, 'void', '', 0);\n              const /** @type {?} */ player = new NoopAnimationPlayer();\n              this._queuePlayer(element, triggerName, player, event);\n            }\n          });\n        }\n      }\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(callback);\n      } else {\n        callback();\n      }\n    });\n\n    this._queuedRemovals.clear();\n    this._flaggedInserts.clear();\n\n    // this means that one or more leave animations were detected\n    if (flushAgain) {\n      this._flushQueuedAnimations();\n      this._clearPendingListenerRemovals();\n    }\n  }\n}\n\nfunction DomAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nDomAnimationEngine.prototype._flaggedInserts;\n/** @type {?} */\nDomAnimationEngine.prototype._queuedRemovals;\n/** @type {?} */\nDomAnimationEngine.prototype._queuedTransitionAnimations;\n/** @type {?} */\nDomAnimationEngine.prototype._activeTransitionAnimations;\n/** @type {?} */\nDomAnimationEngine.prototype._activeElementAnimations;\n/** @type {?} */\nDomAnimationEngine.prototype._elementTriggerStates;\n/** @type {?} */\nDomAnimationEngine.prototype._triggers;\n/** @type {?} */\nDomAnimationEngine.prototype._triggerListeners;\n/** @type {?} */\nDomAnimationEngine.prototype._pendingListenerRemovals;\n/** @type {?} */\nDomAnimationEngine.prototype._driver;\n/** @type {?} */\nDomAnimationEngine.prototype._normalizer;\n}\n\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} defaultValue\n * @return {?}\n */\nfunction getOrSetAsInMap(map: Map<any, any>, key: any, defaultValue: any) {\n  let /** @type {?} */ value = map.get(key);\n  if (!value) {\n    map.set(key, value = defaultValue);\n  }\n  return value;\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} value\n * @return {?}\n */\nfunction deleteFromArrayMap(map: Map<any, any[]>, key: any, value: any) {\n  let /** @type {?} */ arr = map.get(key);\n  if (arr) {\n    const /** @type {?} */ index = arr.indexOf(value);\n    if (index >= 0) {\n      arr.splice(index, 1);\n      if (arr.length == 0) {\n        map.delete(key);\n      }\n    }\n  }\n}\n/**\n * @param {?} players\n * @return {?}\n */\nfunction optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n/**\n * @param {?} source\n * @return {?}\n */\nfunction copyArray(source: any[]): any[] {\n  return source ? source.splice(0) : [];\n}\n/**\n * @param {?} triggerName\n * @param {?} eventName\n * @return {?}\n */\nfunction validatePlayerEvent(triggerName: string, eventName: string) {\n  switch (eventName) {\n    case 'start':\n    case 'done':\n      return;\n    default:\n      throw new Error(\n          `The provided animation trigger event \"${eventName}\" for the animation trigger \"${triggerName}\" is not supported!`);\n  }\n}\n/**\n * @param {?} player\n * @param {?} eventName\n * @param {?} baseEvent\n * @param {?} callback\n * @return {?}\n */\nfunction listenOnPlayer(\n    player: AnimationPlayer, eventName: string, baseEvent: AnimationEvent,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => {\n        const /** @type {?} */ event = copyAnimationEvent(baseEvent);\n        event.phaseName = 'start';\n        callback(event);\n      });\n      break;\n    case 'done':\n      player.onDone(() => {\n        const /** @type {?} */ event = copyAnimationEvent(baseEvent);\n        event.phaseName = 'done';\n        callback(event);\n      });\n      break;\n  }\n}\n/**\n * @param {?} e\n * @return {?}\n */\nfunction copyAnimationEvent(e: AnimationEvent): AnimationEvent {\n  return makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, e.phaseName, e.totalTime);\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} phaseName\n * @param {?} totalTime\n * @return {?}\n */\nfunction makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string,\n    totalTime: number): AnimationEvent {\n  return /** @type {?} */(( <AnimationEvent>{element, triggerName, fromState, toState, phaseName, totalTime}));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationSequenceMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, ɵStyleData} from '@angular/animations';\n\nimport {copyStyles, normalizeStyles} from '../util';\n\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\nimport {parseTransitionExpr} from './animation_transition_expr';\nimport {AnimationTransitionFactory} from './animation_transition_factory';\nimport {AnimationTransitionInstruction, createTransitionInstruction} from './animation_transition_instruction';\nimport {validateAnimationSequence} from './animation_validator_visitor';\n/**\n * \\@experimental Animation support is experimental.\n * @param {?} name\n * @param {?} definitions\n * @return {?}\n */\nexport function buildTrigger(name: string, definitions: AnimationMetadata[]): AnimationTrigger {\n  return new AnimationTriggerVisitor().buildTrigger(name, definitions);\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class AnimationTrigger {\npublic transitionFactories: AnimationTransitionFactory[] = [];\npublic states: {[stateName: string]: ɵStyleData} = {};\n/**\n * @param {?} name\n * @param {?} states\n * @param {?} _transitionAsts\n */\nconstructor(\npublic name: string, states: {[stateName: string]: ɵStyleData},\nprivate _transitionAsts: AnimationTransitionMetadata[]) {\n    Object.keys(states).forEach(\n        stateName => { this.states[stateName] = copyStyles(states[stateName], false); });\n\n    const errors: string[] = [];\n    _transitionAsts.forEach(ast => {\n      const exprs = parseTransitionExpr(ast.expr, errors);\n      const sequenceErrors = validateAnimationSequence(ast);\n      if (sequenceErrors.length) {\n        errors.push(...sequenceErrors);\n      } else {\n        this.transitionFactories.push(\n            new AnimationTransitionFactory(this.name, ast, exprs, states));\n      }\n    });\n\n    if (errors.length) {\n      const LINE_START = '\\n - ';\n      throw new Error(\n          `Animation parsing for the ${name} trigger have failed:${LINE_START}${errors.join(LINE_START)}`);\n    }\n  }\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\ncreateFallbackInstruction(currentState: any, nextState: any): AnimationTransitionInstruction {\n    const /** @type {?} */ backupStateStyles = this.states['*'] || {};\n    const /** @type {?} */ currentStateStyles = this.states[currentState] || backupStateStyles;\n    const /** @type {?} */ nextStateStyles = this.states[nextState] || backupStateStyles;\n    return createTransitionInstruction(\n        this.name, currentState, nextState, nextState == 'void', currentStateStyles,\n        nextStateStyles, []);\n  }\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatchTransition(currentState: any, nextState: any): AnimationTransitionInstruction {\n    for (let /** @type {?} */ i = 0; i < this.transitionFactories.length; i++) {\n      let /** @type {?} */ result = this.transitionFactories[i].match(currentState, nextState);\n      if (result) return result;\n    }\n  }\n}\n\nfunction AnimationTrigger_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTrigger.prototype.transitionFactories;\n/** @type {?} */\nAnimationTrigger.prototype.states;\n/** @type {?} */\nAnimationTrigger.prototype.name;\n/** @type {?} */\nAnimationTrigger.prototype._transitionAsts;\n}\n\nclass AnimationTriggerContext {\npublic errors: string[] = [];\npublic states: {[stateName: string]: ɵStyleData} = {};\npublic transitions: AnimationTransitionMetadata[] = [];\n}\n\nfunction AnimationTriggerContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTriggerContext.prototype.errors;\n/** @type {?} */\nAnimationTriggerContext.prototype.states;\n/** @type {?} */\nAnimationTriggerContext.prototype.transitions;\n}\n\nclass AnimationTriggerVisitor implements AnimationDslVisitor {\n/**\n * @param {?} name\n * @param {?} definitions\n * @return {?}\n */\nbuildTrigger(name: string, definitions: AnimationMetadata[]): AnimationTrigger {\n    const /** @type {?} */ context = new AnimationTriggerContext();\n    definitions.forEach(def => visitAnimationNode(this, def, context));\n    return new AnimationTrigger(name, context.states, context.transitions);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: AnimationStateMetadata, context: any): any {\n    const /** @type {?} */ styles = normalizeStyles(ast.styles.styles);\n    ast.name.split(/\\s*,\\s*/).forEach(name => { context.states[name] = styles; });\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: AnimationTransitionMetadata, context: any): any {\n    context.transitions.push(ast);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: AnimationSequenceMetadata, context: any) {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: AnimationGroupMetadata, context: any) {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: AnimationAnimateMetadata, context: any) {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: AnimationStyleMetadata, context: any) {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(ast: AnimationKeyframesSequenceMetadata, context: any) {\n    // these values are not visited in this AST\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationSequenceMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, sequence} from '@angular/animations';\n\nimport {normalizeStyles, parseTimeExpression} from '../util';\n\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\n\nexport type StyleTimeTuple = {\n  startTime: number; endTime: number;\n};\n/**\n * @param {?} ast\n * @return {?}\n */\nexport function validateAnimationSequence(ast: AnimationMetadata) {\n  const /** @type {?} */ normalizedAst =\n      Array.isArray(ast) ? sequence( /** @type {?} */((<AnimationMetadata[]>ast))) : /** @type {?} */(( <AnimationMetadata>ast));\n  return new AnimationValidatorVisitor().validate(normalizedAst);\n}\nexport class AnimationValidatorVisitor implements AnimationDslVisitor {\n/**\n * @param {?} ast\n * @return {?}\n */\nvalidate(ast: AnimationMetadata): string[] {\n    const /** @type {?} */ context = new AnimationValidatorContext();\n    visitAnimationNode(this, ast, context);\n    return context.errors;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: AnimationStateMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: AnimationTransitionMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: AnimationSequenceMetadata, context: AnimationValidatorContext): any {\n    ast.steps.forEach(step => visitAnimationNode(this, step, context));\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: AnimationGroupMetadata, context: AnimationValidatorContext): any {\n    const /** @type {?} */ currentTime = context.currentTime;\n    let /** @type {?} */ furthestTime = 0;\n    ast.steps.forEach(step => {\n      context.currentTime = currentTime;\n      visitAnimationNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n    });\n    context.currentTime = furthestTime;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: AnimationAnimateMetadata, context: AnimationValidatorContext): any {\n    // we reassign the timings here so that they are not reparsed each\n    // time an animation occurs\n    context.currentAnimateTimings = ast.timings =\n        parseTimeExpression( /** @type {?} */((<string|number>ast.timings)), context.errors);\n\n    const /** @type {?} */ astType = ast.styles && ast.styles.type;\n    if (astType == AnimationMetadataType.KeyframeSequence) {\n      this.visitKeyframeSequence( /** @type {?} */((<AnimationKeyframesSequenceMetadata>ast.styles)), context);\n    } else {\n      context.currentTime +=\n          context.currentAnimateTimings.duration + context.currentAnimateTimings.delay;\n      if (astType == AnimationMetadataType.Style) {\n        this.visitStyle( /** @type {?} */((<AnimationStyleMetadata>ast.styles)), context);\n      }\n    }\n\n    context.currentAnimateTimings = null;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: AnimationStyleMetadata, context: AnimationValidatorContext): any {\n    const /** @type {?} */ styleData = normalizeStyles(ast.styles);\n    const /** @type {?} */ timings = context.currentAnimateTimings;\n    let /** @type {?} */ endTime = context.currentTime;\n    let /** @type {?} */ startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n    Object.keys(styleData).forEach(prop => {\n      const /** @type {?} */ collectedEntry = context.collectedStyles[prop];\n      let /** @type {?} */ updateCollectedStyle = true;\n      if (collectedEntry) {\n        if (startTime != endTime && startTime >= collectedEntry.startTime &&\n            endTime <= collectedEntry.endTime) {\n          context.errors.push(\n              `The CSS property \"${prop}\" that exists between the times of \"${collectedEntry.startTime}ms\" and \"${collectedEntry.endTime}ms\" is also being animated in a parallel animation between the times of \"${startTime}ms\" and \"${endTime}ms\"`);\n          updateCollectedStyle = false;\n        }\n\n        // we always choose the smaller start time value since we\n        // want to have a record of the entire animation window where\n        // the style property is being animated in between\n        startTime = collectedEntry.startTime;\n      }\n      if (updateCollectedStyle) {\n        context.collectedStyles[prop] = {startTime, endTime};\n      }\n    });\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(\n      ast: AnimationKeyframesSequenceMetadata, context: AnimationValidatorContext): any {\n    let /** @type {?} */ totalKeyframesWithOffsets = 0;\n    const /** @type {?} */ offsets: number[] = [];\n    let /** @type {?} */ offsetsOutOfOrder = false;\n    let /** @type {?} */ keyframesOutOfRange = false;\n    let /** @type {?} */ previousOffset: number = 0;\n    ast.steps.forEach(step => {\n      const /** @type {?} */ styleData = normalizeStyles(step.styles);\n      let /** @type {?} */ offset = 0;\n      if (styleData.hasOwnProperty('offset')) {\n        totalKeyframesWithOffsets++;\n        offset = /** @type {?} */(( <number>styleData['offset']));\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n    });\n\n    if (keyframesOutOfRange) {\n      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);\n    }\n\n    if (offsetsOutOfOrder) {\n      context.errors.push(`Please ensure that all keyframe offsets are in order`);\n    }\n\n    const /** @type {?} */ length = ast.steps.length;\n    let /** @type {?} */ generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = 1 / length;\n    }\n\n    const /** @type {?} */ limit = length - 1;\n    const /** @type {?} */ currentTime = context.currentTime;\n    const /** @type {?} */ animateDuration = context.currentAnimateTimings.duration;\n    ast.steps.forEach((step, i) => {\n      const /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n      const /** @type {?} */ durationUpToThisFrame = offset * animateDuration;\n      context.currentTime =\n          currentTime + context.currentAnimateTimings.delay + durationUpToThisFrame;\n      context.currentAnimateTimings.duration = durationUpToThisFrame;\n      this.visitStyle(step, context);\n    });\n  }\n}\nexport class AnimationValidatorContext {\npublic errors: string[] = [];\npublic currentTime: number = 0;\npublic currentAnimateTimings: AnimateTimings;\npublic collectedStyles: {[propName: string]: StyleTimeTuple} = {};\n}\n\nfunction AnimationValidatorContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationValidatorContext.prototype.errors;\n/** @type {?} */\nAnimationValidatorContext.prototype.currentTime;\n/** @type {?} */\nAnimationValidatorContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationValidatorContext.prototype.collectedStyles;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationTransitionMetadata, sequence, ɵStyleData} from '@angular/animations';\n\nimport {buildAnimationKeyframes} from './animation_timeline_visitor';\nimport {TransitionMatcherFn} from './animation_transition_expr';\nimport {AnimationTransitionInstruction, createTransitionInstruction} from './animation_transition_instruction';\nexport class AnimationTransitionFactory {\nprivate _animationAst: AnimationMetadata;\n/**\n * @param {?} _triggerName\n * @param {?} ast\n * @param {?} matchFns\n * @param {?} _stateStyles\n */\nconstructor(\nprivate _triggerName: string, ast: AnimationTransitionMetadata,\nprivate matchFns: TransitionMatcherFn[],\nprivate _stateStyles: {[stateName: string]: ɵStyleData}) {\n    const normalizedAst = Array.isArray(ast.animation) ?\n        sequence(<AnimationMetadata[]>ast.animation) :\n        <AnimationMetadata>ast.animation;\n    this._animationAst = normalizedAst;\n  }\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatch(currentState: any, nextState: any): AnimationTransitionInstruction {\n    if (!oneOrMoreTransitionsMatch(this.matchFns, currentState, nextState)) return;\n\n    const /** @type {?} */ backupStateStyles = this._stateStyles['*'] || {};\n    const /** @type {?} */ currentStateStyles = this._stateStyles[currentState] || backupStateStyles;\n    const /** @type {?} */ nextStateStyles = this._stateStyles[nextState] || backupStateStyles;\n\n    const /** @type {?} */ timelines =\n        buildAnimationKeyframes(this._animationAst, currentStateStyles, nextStateStyles);\n\n    return createTransitionInstruction(\n        this._triggerName, currentState, nextState, nextState === 'void', currentStateStyles,\n        nextStateStyles, timelines);\n  }\n}\n\nfunction AnimationTransitionFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionFactory.prototype._animationAst;\n/** @type {?} */\nAnimationTransitionFactory.prototype._triggerName;\n/** @type {?} */\nAnimationTransitionFactory.prototype.matchFns;\n/** @type {?} */\nAnimationTransitionFactory.prototype._stateStyles;\n}\n\n/**\n * @param {?} matchFns\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nfunction oneOrMoreTransitionsMatch(\n    matchFns: TransitionMatcherFn[], currentState: any, nextState: any): boolean {\n  return matchFns.some(fn => fn(currentState, nextState));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\n\nexport interface AnimationTransitionInstruction extends AnimationEngineInstruction {\n  triggerName: string;\n  isRemovalTransition: boolean;\n  fromState: string;\n  fromStyles: ɵStyleData;\n  toState: string;\n  toStyles: ɵStyleData;\n  timelines: AnimationTimelineInstruction[];\n}\n/**\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} isRemovalTransition\n * @param {?} fromStyles\n * @param {?} toStyles\n * @param {?} timelines\n * @return {?}\n */\nexport function createTransitionInstruction(\n    triggerName: string, fromState: string, toState: string, isRemovalTransition: boolean,\n    fromStyles: ɵStyleData, toStyles: ɵStyleData,\n    timelines: AnimationTimelineInstruction[]): AnimationTransitionInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TransitionAnimation,\n    triggerName,\n    isRemovalTransition,\n    fromState,\n    fromStyles,\n    toState,\n    toStyles,\n    timelines\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimateTimings, AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationSequenceMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, sequence, style, ɵStyleData} from '@angular/animations';\n\nimport {copyStyles, normalizeStyles, parseTimeExpression} from '../util';\n\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\n/**\n * @param {?} ast\n * @param {?=} startingStyles\n * @param {?=} finalStyles\n * @return {?}\n */\nexport function buildAnimationKeyframes(\n    ast: AnimationMetadata | AnimationMetadata[], startingStyles: ɵStyleData = {},\n    finalStyles: ɵStyleData = {}): AnimationTimelineInstruction[] {\n  const /** @type {?} */ normalizedAst =\n      Array.isArray(ast) ? sequence( /** @type {?} */((<AnimationMetadata[]>ast))) : /** @type {?} */(( <AnimationMetadata>ast));\n  return new AnimationTimelineVisitor().buildKeyframes(normalizedAst, startingStyles, finalStyles);\n}\n\nexport declare type StyleAtTime = {\n  time: number; value: string | number;\n};\nexport class AnimationTimelineContext {\n  currentTimeline: TimelineBuilder;\n  currentAnimateTimings: AnimateTimings;\n  previousNode: AnimationMetadata = /** @type {?} */(( <AnimationMetadata>{}));\n  subContextCount = 0;\n/**\n * @param {?} errors\n * @param {?} timelines\n * @param {?=} initialTimeline\n */\nconstructor(\npublic errors: any[],\npublic timelines: TimelineBuilder[],\n      initialTimeline: TimelineBuilder = null) {\n    this.currentTimeline = initialTimeline || new TimelineBuilder(0);\n    timelines.push(this.currentTimeline);\n  }\n/**\n * @return {?}\n */\ncreateSubContext(): AnimationTimelineContext {\n    const /** @type {?} */ context =\n        new AnimationTimelineContext(this.errors, this.timelines, this.currentTimeline.fork());\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n    this.subContextCount++;\n    return context;\n  }\n/**\n * @param {?=} newTime\n * @return {?}\n */\ntransformIntoNewTimeline(newTime = 0) {\n    this.currentTimeline = this.currentTimeline.fork(newTime);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nincrementTime(time: number) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n}\n\nfunction AnimationTimelineContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTimelineContext.prototype.currentTimeline;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationTimelineContext.prototype.previousNode;\n/** @type {?} */\nAnimationTimelineContext.prototype.subContextCount;\n/** @type {?} */\nAnimationTimelineContext.prototype.errors;\n/** @type {?} */\nAnimationTimelineContext.prototype.timelines;\n}\n\nexport class AnimationTimelineVisitor implements AnimationDslVisitor {\n/**\n * @param {?} ast\n * @param {?} startingStyles\n * @param {?} finalStyles\n * @return {?}\n */\nbuildKeyframes(ast: AnimationMetadata, startingStyles: ɵStyleData, finalStyles: ɵStyleData):\n      AnimationTimelineInstruction[] {\n    const /** @type {?} */ context = new AnimationTimelineContext([], []);\n    context.currentTimeline.setStyles(startingStyles);\n\n    visitAnimationNode(this, ast, context);\n    const /** @type {?} */ normalizedFinalStyles = copyStyles(finalStyles, true);\n\n    // this is a special case for when animate(TIME) is used (without any styles)\n    // thus indicating to create an animation arc between the final keyframe and\n    // the destination styles. When this occurs we need to ensure that the styles\n    // that are missing on the finalStyles map are set to AUTO\n    if (Object.keys(context.currentTimeline.getFinalKeyframe()).length == 0) {\n      context.currentTimeline.properties.forEach(prop => {\n        const /** @type {?} */ val = normalizedFinalStyles[prop];\n        if (val == null) {\n          normalizedFinalStyles[prop] = AUTO_STYLE;\n        }\n      });\n    }\n\n    context.currentTimeline.setStyles(normalizedFinalStyles);\n    const /** @type {?} */ timelineInstructions: AnimationTimelineInstruction[] = [];\n    context.timelines.forEach(timeline => {\n      // this checks to see if an actual animation happened\n      if (timeline.hasStyling()) {\n        timelineInstructions.push(timeline.buildKeyframes());\n      }\n    });\n\n    if (timelineInstructions.length == 0) {\n      timelineInstructions.push(createTimelineInstruction([], 0, 0, ''));\n    }\n    return timelineInstructions;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: AnimationStateMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: AnimationTransitionMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: AnimationSequenceMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ subContextCount = context.subContextCount;\n    if (context.previousNode.type == AnimationMetadataType.Style) {\n      context.currentTimeline.forwardFrame();\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    ast.steps.forEach(s => visitAnimationNode(this, s, context));\n\n    // this means that some animation function within the sequence\n    // ended up creating a sub timeline (which means the current\n    // timeline cannot overlap with the contents of the sequence)\n    if (context.subContextCount > subContextCount) {\n      context.transformIntoNewTimeline();\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: AnimationGroupMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ innerTimelines: TimelineBuilder[] = [];\n    let /** @type {?} */ furthestTime = context.currentTimeline.currentTime;\n    ast.steps.forEach(s => {\n      const /** @type {?} */ innerContext = context.createSubContext();\n      visitAnimationNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: AnimationAnimateMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ timings = ast.timings.hasOwnProperty('duration') ? /** @type {?} */((\n        <AnimateTimings>ast.timings)) :\n        parseTimeExpression( /** @type {?} */((<string|number>ast.timings)), context.errors);\n    context.currentAnimateTimings = timings;\n\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    const /** @type {?} */ astType = ast.styles ? ast.styles.type : -1;\n    if (astType == AnimationMetadataType.KeyframeSequence) {\n      this.visitKeyframeSequence( /** @type {?} */((<AnimationKeyframesSequenceMetadata>ast.styles)), context);\n    } else {\n      let /** @type {?} */ styleAst = /** @type {?} */(( ast.styles as AnimationStyleMetadata));\n      if (!styleAst && timings.easing) {\n        styleAst = style({easing: timings.easing});\n      }\n      context.incrementTime(timings.duration);\n      if (styleAst) {\n        this.visitStyle(styleAst, context);\n      }\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: AnimationStyleMetadata, context: AnimationTimelineContext) {\n    // this is a special case when a style() call is issued directly after\n    // a call to animate(). If the clock is not forwarded by one frame then\n    // the style() calls will be merged into the previous animate() call\n    // which is incorrect.\n    if (!context.currentAnimateTimings &&\n        context.previousNode.type == AnimationMetadataType.Animate) {\n      context.currentTimeline.forwardFrame();\n    }\n\n    const /** @type {?} */ normalizedStyles = normalizeStyles(ast.styles);\n    const /** @type {?} */ easing = context.currentAnimateTimings && context.currentAnimateTimings.easing;\n    if (easing) {\n      normalizedStyles['easing'] = easing;\n    }\n\n    context.currentTimeline.setStyles(normalizedStyles);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(\n      ast: AnimationKeyframesSequenceMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;\n    const /** @type {?} */ limit = ast.steps.length - 1;\n    const /** @type {?} */ firstKeyframe = ast.steps[0];\n\n    let /** @type {?} */ offsetGap = 0;\n    const /** @type {?} */ containsOffsets = getOffset(firstKeyframe) != null;\n    if (!containsOffsets) {\n      offsetGap = MAX_KEYFRAME_OFFSET / limit;\n    }\n\n    const /** @type {?} */ startTime = context.currentTimeline.duration;\n    const /** @type {?} */ duration = context.currentAnimateTimings.duration;\n    const /** @type {?} */ innerContext = context.createSubContext();\n    const /** @type {?} */ innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = context.currentAnimateTimings.easing;\n\n    ast.steps.forEach((step: AnimationStyleMetadata, i: number) => {\n      const /** @type {?} */ normalizedStyles = normalizeStyles(step.styles);\n      const /** @type {?} */ offset = containsOffsets ?\n          (step.offset != null ? step.offset : parseFloat( /** @type {?} */((normalizedStyles['offset'] as string)))) :\n          (i == limit ? MAX_KEYFRAME_OFFSET : i * offsetGap);\n      innerTimeline.forwardTime(offset * duration);\n      innerTimeline.setStyles(normalizedStyles);\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child even if the new timeline below is not used\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n}\nexport class TimelineBuilder {\npublic duration: number = 0;\npublic easing: string = '';\nprivate _currentKeyframe: ɵStyleData;\nprivate _keyframes = new Map<number, ɵStyleData>();\nprivate _styleSummary: {[prop: string]: StyleAtTime} = {};\nprivate _localTimelineStyles: ɵStyleData;\nprivate _backFill: ɵStyleData = {};\n/**\n * @param {?} startTime\n * @param {?=} _globalTimelineStyles\n */\nconstructor(public startTime: number,\nprivate _globalTimelineStyles: ɵStyleData = null) {\n    this._localTimelineStyles = Object.create(this._backFill, {});\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n    }\n    this._loadKeyframe();\n  }\n/**\n * @return {?}\n */\nhasStyling(): boolean { return this._keyframes.size > 1; }\n/**\n * @return {?}\n */\nget currentTime() { return this.startTime + this.duration; }\n/**\n * @param {?=} currentTime\n * @return {?}\n */\nfork(currentTime = 0): TimelineBuilder {\n    return new TimelineBuilder(currentTime || this.currentTime, this._globalTimelineStyles);\n  }\n/**\n * @return {?}\n */\nprivate _loadKeyframe() {\n    this._currentKeyframe = this._keyframes.get(this.duration);\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = Object.create(this._backFill, {});\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n/**\n * @return {?}\n */\nforwardFrame() {\n    this.duration++;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nforwardTime(time: number) {\n    this.duration = time;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} prop\n * @param {?} value\n * @return {?}\n */\nprivate _updateStyle(prop: string, value: string|number) {\n    if (prop != 'easing') {\n      this._localTimelineStyles[prop] = value;\n      this._globalTimelineStyles[prop] = value;\n      this._styleSummary[prop] = {time: this.currentTime, value};\n    }\n  }\n/**\n * @param {?} styles\n * @return {?}\n */\nsetStyles(styles: ɵStyleData) {\n    Object.keys(styles).forEach(prop => {\n      if (prop !== 'offset') {\n        const /** @type {?} */ val = styles[prop];\n        this._currentKeyframe[prop] = val;\n        if (prop !== 'easing' && !this._localTimelineStyles[prop]) {\n          this._backFill[prop] = this._globalTimelineStyles[prop] || AUTO_STYLE;\n        }\n        this._updateStyle(prop, val);\n      }\n    });\n    Object.keys(this._localTimelineStyles).forEach(prop => {\n      if (!this._currentKeyframe.hasOwnProperty(prop)) {\n        this._currentKeyframe[prop] = this._localTimelineStyles[prop];\n      }\n    });\n  }\n/**\n * @return {?}\n */\nsnapshotCurrentStyles() { copyStyles(this._localTimelineStyles, false, this._currentKeyframe); }\n/**\n * @return {?}\n */\ngetFinalKeyframe() { return this._keyframes.get(this.duration); }\n/**\n * @return {?}\n */\nget properties() {\n    const /** @type {?} */ properties: string[] = [];\n    for (let /** @type {?} */ prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n/**\n * @param {?} timeline\n * @return {?}\n */\nmergeTimelineCollectedStyles(timeline: TimelineBuilder) {\n    Object.keys(timeline._styleSummary).forEach(prop => {\n      const /** @type {?} */ details0 = this._styleSummary[prop];\n      const /** @type {?} */ details1 = timeline._styleSummary[prop];\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    const /** @type {?} */ finalKeyframes: ɵStyleData[] = [];\n    // special case for when there are only start/destination\n    // styles but no actual animation animate steps...\n    if (this.duration == 0) {\n      const /** @type {?} */ targetKeyframe = this.getFinalKeyframe();\n\n      const /** @type {?} */ firstKeyframe = copyStyles(targetKeyframe, true);\n      firstKeyframe['offset'] = 0;\n      finalKeyframes.push(firstKeyframe);\n\n      const /** @type {?} */ lastKeyframe = copyStyles(targetKeyframe, true);\n      lastKeyframe['offset'] = 1;\n      finalKeyframes.push(lastKeyframe);\n    } else {\n      this._keyframes.forEach((keyframe, time) => {\n        const /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);\n        finalKeyframe['offset'] = time / this.duration;\n        finalKeyframes.push(finalKeyframe);\n      });\n    }\n\n    return createTimelineInstruction(finalKeyframes, this.duration, this.startTime, this.easing);\n  }\n}\n\nfunction TimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineBuilder.prototype.duration;\n/** @type {?} */\nTimelineBuilder.prototype.easing;\n/** @type {?} */\nTimelineBuilder.prototype._currentKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._keyframes;\n/** @type {?} */\nTimelineBuilder.prototype._styleSummary;\n/** @type {?} */\nTimelineBuilder.prototype._localTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._backFill;\n/** @type {?} */\nTimelineBuilder.prototype.startTime;\n/** @type {?} */\nTimelineBuilder.prototype._globalTimelineStyles;\n}\n\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction getOffset(ast: AnimationStyleMetadata): number {\n  let /** @type {?} */ offset = ast.offset;\n  if (offset == null) {\n    const /** @type {?} */ styles = ast.styles;\n    if (Array.isArray(styles)) {\n      for (let /** @type {?} */ i = 0; i < styles.length; i++) {\n        const /** @type {?} */ o = /** @type {?} */(( styles[i]['offset'] as number));\n        if (o != null) {\n          offset = o;\n          break;\n        }\n      }\n    } else {\n      offset = /** @type {?} */(( styles['offset'] as number));\n    }\n  }\n  return offset;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\n\nexport interface AnimationTimelineInstruction extends AnimationEngineInstruction {\n  keyframes: ɵStyleData[];\n  duration: number;\n  delay: number;\n  totalTime: number;\n  easing: string;\n}\n/**\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @return {?}\n */\nexport function createTimelineInstruction(\n    keyframes: ɵStyleData[], duration: number, delay: number,\n    easing: string): AnimationTimelineInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TimelineAnimation,\n    keyframes,\n    duration,\n    delay,\n    totalTime: duration + delay, easing\n  };\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn = (fromState: any, toState: any) => boolean;\n/**\n * @param {?} transitionValue\n * @param {?} errors\n * @return {?}\n */\nexport function parseTransitionExpr(\n    transitionValue: string | TransitionMatcherFn, errors: string[]): TransitionMatcherFn[] {\n  const /** @type {?} */ expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    ( /** @type {?} */((<string>transitionValue)))\n        .split(/\\s*,\\s*/)\n        .forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push( /** @type {?} */((<TransitionMatcherFn>transitionValue)));\n  }\n  return expressions;\n}\n/**\n * @param {?} eventStr\n * @param {?} expressions\n * @param {?} errors\n * @return {?}\n */\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: string[]) {\n  if (eventStr[0] == ':') {\n    eventStr = parseAnimationAlias(eventStr, errors);\n  }\n  const /** @type {?} */ match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(`The provided transition expression \"${eventStr}\" is not supported`);\n    return expressions;\n  }\n\n  const /** @type {?} */ fromState = match[1];\n  const /** @type {?} */ separator = match[2];\n  const /** @type {?} */ toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction parseAnimationAlias(alias: string, errors: string[]): string {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    default:\n      errors.push(`The transition alias value \"${alias}\" is not supported`);\n      return '* => *';\n  }\n}\n/**\n * @param {?} lhs\n * @param {?} rhs\n * @return {?}\n */\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  return (fromState: any, toState: any): boolean => {\n    const /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    const /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;\n    return lhsMatch && rhsMatch;\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationSequenceMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata} from '@angular/animations';\n\nexport interface AnimationDslVisitor {\n  visitState(ast: AnimationStateMetadata, context: any): any;\n  visitTransition(ast: AnimationTransitionMetadata, context: any): any;\n  visitSequence(ast: AnimationSequenceMetadata, context: any): any;\n  visitGroup(ast: AnimationGroupMetadata, context: any): any;\n  visitAnimate(ast: AnimationAnimateMetadata, context: any): any;\n  visitStyle(ast: AnimationStyleMetadata, context: any): any;\n  visitKeyframeSequence(ast: AnimationKeyframesSequenceMetadata, context: any): any;\n}\n/**\n * @param {?} visitor\n * @param {?} node\n * @param {?} context\n * @return {?}\n */\nexport function visitAnimationNode(\n    visitor: AnimationDslVisitor, node: AnimationMetadata, context: any) {\n  switch (node.type) {\n    case AnimationMetadataType.State:\n      return visitor.visitState( /** @type {?} */((<AnimationStateMetadata>node)), context);\n    case AnimationMetadataType.Transition:\n      return visitor.visitTransition( /** @type {?} */((<AnimationTransitionMetadata>node)), context);\n    case AnimationMetadataType.Sequence:\n      return visitor.visitSequence( /** @type {?} */((<AnimationSequenceMetadata>node)), context);\n    case AnimationMetadataType.Group:\n      return visitor.visitGroup( /** @type {?} */((<AnimationGroupMetadata>node)), context);\n    case AnimationMetadataType.Animate:\n      return visitor.visitAnimate( /** @type {?} */((<AnimationAnimateMetadata>node)), context);\n    case AnimationMetadataType.KeyframeSequence:\n      return visitor.visitKeyframeSequence( /** @type {?} */((<AnimationKeyframesSequenceMetadata>node)), context);\n    case AnimationMetadataType.Style:\n      return visitor.visitStyle( /** @type {?} */((<AnimationStyleMetadata>node)), context);\n    default:\n      throw new Error(`Unable to resolve animation metadata node #${node.type}`);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, ɵStyleData} from '@angular/animations';\n\nexport const /** @type {?} */ ONE_SECOND = 1000;\n/**\n * @param {?} exp\n * @param {?} errors\n * @return {?}\n */\nexport function parseTimeExpression(exp: string | number, errors: string[]): AnimateTimings {\n  const /** @type {?} */ regex = /^([\\.\\d]+)(m?s)(?:\\s+([\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = null;\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: null};\n    }\n\n    let /** @type {?} */ durationMatch = parseFloat(matches[1]);\n    const /** @type {?} */ durationUnit = matches[2];\n    if (durationUnit == 's') {\n      durationMatch *= ONE_SECOND;\n    }\n    duration = Math.floor(durationMatch);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    const /** @type {?} */ delayUnit = matches[4];\n    if (delayMatch != null) {\n      let /** @type {?} */ delayVal: number = parseFloat(delayMatch);\n      if (delayUnit != null && delayUnit == 's') {\n        delayVal *= ONE_SECOND;\n      }\n      delay = Math.floor(delayVal);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  return {duration, delay, easing};\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const /** @type {?} */ normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n/**\n * @param {?} styles\n * @param {?} readPrototype\n * @param {?=} destination\n * @return {?}\n */\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let /** @type {?} */ prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    Object.keys(styles).forEach(prop => destination[prop] = styles[prop]);\n  }\n  return destination;\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => element.style[prop] = styles[prop]);\n  }\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      element.style[prop] = '';\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer, AnimationTriggerMetadata} from '@angular/animations';\n/**\n * @abstract\n */\nexport abstract class AnimationEngine {\n/**\n * @abstract\n * @param {?} trigger\n * @param {?=} name\n * @return {?}\n */\nregisterTrigger(trigger: AnimationTriggerMetadata, name?: string) {}\n/**\n * @abstract\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonInsert(element: any, domFn: () => any) {}\n/**\n * @abstract\n * @param {?} element\n * @param {?} domFn\n * @return {?}\n */\nonRemove(element: any, domFn: () => any) {}\n/**\n * @abstract\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(element: any, property: string, value: any) {}\n/**\n * @abstract\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      element: any, eventName: string, eventPhase: string,\n      callback: (event: any) => any) {}\n/**\n * @abstract\n * @return {?}\n */\nflush() {}\n/**\n * @return {?}\n */\nget activePlayers(): AnimationPlayer[] { throw new Error('...'); }\n/**\n * @return {?}\n */\nget queuedPlayers(): AnimationPlayer[] { throw new Error('...'); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer, NoopAnimationPlayer} from '@angular/animations';\n\n\n\n/**\n * @experimental\n */\nexport class NoopAnimationDriver implements AnimationDriver {\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): AnimationPlayer {\n    return new NoopAnimationPlayer();\n  }\n}\n\n/**\n * @experimental\n */\nexport abstract class AnimationDriver {\n  static NOOP: AnimationDriver = new NoopAnimationDriver();\n  abstract animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers?: any[]): any;\n}\n"],"names":["AUTO_STYLE","sequence","NoopAnimationPlayer","style"],"mappings":"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"}